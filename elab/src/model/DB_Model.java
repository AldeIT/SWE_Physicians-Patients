package model;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;

import javafx.beans.Observable;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;




/**
 * DB_Model - Class that performs all database operations - Singleton Design Pattern
 *
 * @author Aldegheri Alessandro, Venturi Davide, Zerman Nicol√≤
 * @version 1.0
 */
public class DB_Model {
	
	/**
	 * Prints the log on terminal.
	 *
	 * @param o the log to be printed.
	 */
	public void log(Object o){
        System.out.println(o);
    }
	
	/**
	 *Class Attributes
	 */
	private static DB_Model single_instance = null;
    private Connection conn;
    
    /**
 	 * Connects to the database located at the specified path.
 	 *
 	 * @throws SQLException if an error occurs while connecting to the database.
 	 */
    public void connect() throws SQLException {
        String url = "jdbc:sqlite:src/model/table.db";
        conn = DriverManager.getConnection(url);
        Statement stmt = conn.createStatement();
        stmt.executeUpdate("PRAGMA foreign_keys = ON;");
        System.out.println("Connection to SQLite has been established.");
    }
	
    /**
	 * Checks whether the specified table exists in the database.
	 *
	 * @param table_name the name of the table to check for existence
	 * @return true if the table exists in the database; false otherwise
	 * @throws SQLException if an error occurs while executing the SQL query
	 */
    public boolean tableExists(String table_name) throws SQLException {
        String q = "SELECT * FROM sqlite_master WHERE tbl_name = '" + table_name + "'";
        log(q);
        ResultSet rs = runQuery(q);
        return rs.next();
    }
    
    /**
	 * Executes the specified SQL query and returns the result set.
	 *
	 * @param q the SQL query to execute
	 * @return the ResultSet generated by executing the query
	 * @throws SQLException if an error occurs while executing the query
	 */
    public ResultSet runQuery(String q) throws SQLException {
    	log(q);
        ResultSet rs = null;
        Statement stmt  = conn.createStatement();
        rs = stmt.executeQuery(q);
        return rs;
    }
    
    /**
	 * Executes the specified SQL statement.
	 *
	 * @param s the SQL statement to execute
	 * @throws SQLException if an error occurs while executing the statement
	 */
    public void runStatement(String s) throws SQLException {
    	log(s);
        Statement stmt  = conn.createStatement();
        stmt.executeUpdate(s);
    }
    
    /**
     * Creates tables if necessary.
     *
     * @throws SQLException if an error occurs while executing the statement
     */
    private DB_Model() throws SQLException{
    	boolean insert = false;
        connect();
        //clearAll();insert = true;
        if (tableExists("physician"))
        {
            log("physician table exists");
        }else {
            log("physician table DO NOT exists");
            resetPhysicianTable();
        };
        
        if (tableExists("log"))
        {
            log("log table exists");
        }else {
            log("log table DO NOT exists");
            resetLogTable();
        };
       
        if (tableExists("patient"))
        {
            log("patient table exists");
        }else {
            log("patient table DO NOT exists");
            resetPatientTable();
        };
        
        if (tableExists("drug"))
        {
            log("drug table exists");
        }else {
            log("drug table DO NOT exists");
            resetDrugTable();
        };
        
        if (tableExists("therapy"))
        {
            log("therapy table exists");
        }else {
            log("therapy table DO NOT exists");
            resetTherapyTable();
        };
        
        if (tableExists("drugIntakes"))
        {
            log("drugIntakes table exists");
        }else {
            log("drugIntakes table DO NOT exists");
            resetDrugIntakesTable();
        };
        
        if (tableExists("pathology"))
        {
            log("pathology table exists");
        }else {
            log("pathology table DO NOT exists");
            resetPathologyTable();
        };
        
        if (tableExists("patient_pathology"))
        {
            log("patient_pathology table exists");
        }else {
            log("patient_pathology table DO NOT exists");
            resetPatientPathologyTable();
        };
        
        if (tableExists("measurement"))
        {
            log("measurement table exists");
        }else {
            log("measurement table DO NOT exists");
            resetMeasurementTable();
        };
        
        if (tableExists("symptom"))
        {
            log("symptom table exists");
        }else {
            log("symptom table DO NOT exists");
            resetSymptomTable();
        };
        
        if (tableExists("measurement_symptom"))
        {
            log("measurement_symptom table exists");
        }else {
            log("measurement_symptom table DO NOT exists");
            resetMeasurementSymptomTable();
        };
        
        if (tableExists("measurement_pathology"))
        {
            log("measurement_symptom table exists");
        }else {
            log("measurement_symptom table DO NOT exists");
            resetMeasurementPathologiesTable();
        };
        
        if (tableExists("measurement_therapy"))
        {
            log("measurement_symptom table exists");
        }else {
            log("measurement_symptom table DO NOT exists");
            resetMeasurementTherapiesTable();
        };
        
        

        /*deleteDataFromTable("measurement_therapy");
        deleteDataFromTable("measurement_pathology");
        deleteDataFromTable("measurement_symptom");
        deleteDataFromTable("symptom");
        deleteDataFromTable("measurement");
        deleteDataFromTable("patient_pathology");
        deleteDataFromTable("pathology");
        deleteDataFromTable("drugIntakes");
        deleteDataFromTable("therapy");
        deleteDataFromTable("drug");
        deleteDataFromTable("log");
        deleteDataFromTable("patient");
        deleteDataFromTable("physician");*/
        
        
        /*System.out.println("Physicians: ");
        ObservableList<Physician> allPhys = getPhysicians();
        for (Physician p: allPhys) {
        	System.out.println(p);
        }
        
        System.out.println("Patients: ");
        ObservableList<Patient> allPat = getPatients();
        for (Patient p: allPat) {
        	System.out.println(p);
        }*/
        if (insert) {
        
        try {
			Physician p = insertPhysician("LDGLSN02S18F861T", "alealde012@gmail.com", "password", "Alessandro", "Aldegheri", "M", LocalDate.of(2002, 11, 18), "Italian", "Danieli", 21, 37141, "Verona", "3497086640");
			insertPhysician("FMMCTN03H20F205V", "physician1@example.com", "password", "Mario", "Rossi", "M", LocalDate.of(2003, 8, 20), "Italian", "Via Roma", 10, 00100, "Roma", "3331234567");
			insertPhysician("MRCLRA04B05F205Y", "physician2@example.com", "password", "Marco", "Bianchi", "M", LocalDate.of(2004, 2, 5), "Italian", "Via Milano", 20, 20100, "Milano", "3332345678");
			insertPhysician("GLLRCC05C06F205S", "physician3@example.com", "password", "Giulia", "Neri", "F", LocalDate.of(2005, 1, 6), "Italian", "Via Napoli", 30, 80100, "Napoli", "3333456789");
			insertPhysician("VNNRCA06D07F205H", "physician4@example.com", "password", "Valentina", "Verdi", "F", LocalDate.of(2006, 10, 7), "Italian", "Via Firenze", 40, 50100, "Firenze", "3334567890");
			insertPhysician("LNTSLN07E08F205D", "physician5@example.com", "password", "Luca", "Russo", "M", LocalDate.of(2007, 7, 8), "Italian", "Via Torino", 50, 10100, "Torino", "3335678901");
			insertPhysician("FRCNLM08F09F205L", "physician6@example.com", "password", "Francesco", "Ferrari", "M", LocalDate.of(2008, 4, 9), "Italian", "Via Bologna", 60, 40100, "Bologna", "3336789012");
			insertPhysician("SLNTLL09G10F205G", "physician7@example.com", "password", "Silvia", "Greco", "F", LocalDate.of(2009, 3, 10), "Italian", "Via Venezia", 70, 30100, "Venezia", "3337890123");
			insertPhysician("GNNMTN10H11F205F", "physician8@example.com", "password", "Giovanni", "Monti", "M", LocalDate.of(2010, 12, 11), "Italian", "Via Genova", 80, 16100, "Genova", "3338901234");
			insertPhysician("CLLNDR11I12F205E", "physician9@example.com", "password", "Claudio", "De Luca", "M", LocalDate.of(2011, 9, 12), "Italian", "Via Palermo", 90, 90100, "Palermo", "3339012345");
			insertPhysician("VRNTLN12L13F205C", "physician10@example.com", "password", "Valeria", "Rontini", "F", LocalDate.of(2012, 6, 13), "Italian", "Via Pisa", 100, 56100, "Pisa", "3330123456");

			Patient pat = insertPatient("VNTDVD02D17L949I", "venturi.davide17@gmail.com", "password", "Davide", "Venturi", "M", LocalDate.of(2002,04,17), "Italian", "Marconi", 89, 37060, "Verona", "3402938423", "Ansia", "LDGLSN02S18F861T");
			Patient pat1 = insertPatient("LVRMRC03D15G618O", "luca.verdi03@gmail.com", "password", "Luca", "Verdi", "M", LocalDate.of(2003, 12, 15), "Italian", "Garibaldi", 23, 37121, "Verona", "3489237641", "Stress", "FRCNLM08F09F205L");
			Patient pat2 = insertPatient("LVRMRZ03D16G618O", "laura.verdi03@gmail.com", "password", "Laura", "Verdi", "F", LocalDate.of(2003, 12, 16), "Italian", "Garibaldi", 23, 37121, "Verona", "3489237642", "Anxiety", "LDGLSN02S18F861T");
			Patient pat3 = insertPatient("MRCCST04T15L219S", "marco.costa04@gmail.com", "password", "Marco", "Costa", "M", LocalDate.of(2004, 01, 15), "Italian", "Mazzini", 45, 37129, "Verona", "3489237643", "Headache", "FRCNLM08F09F205L");
			Patient pat4 = insertPatient("MRCCST04T16L219S", "marco.costa04@gmail.com", "password", "Martina", "Costa", "F", LocalDate.of(2004, 01, 16), "Italian", "Mazzini", 45, 37129, "Verona", "3489237644", "Depression", "LDGLSN02S18F861T");
			Patient pat5 = insertPatient("BRSNTN05A15H501F", "barbara.santoni05@gmail.com", "password", "Barbara", "Santoni", "F", LocalDate.of(2005, 01, 15), "Italian", "Vittorio Emanuele", 67, 37135, "Verona", "3489237645", "Insomnia", "FRCNLM08F09F205L");
			Patient pat6 = insertPatient("MRSRRT05H15F839F", "mario.serra05@gmail.com", "password", "Mario", "Serra", "M", LocalDate.of(2005, 8, 15), "Italian", "Borgo Trento", 12, 37128, "Verona", "3489237646", "Fatigue", "FRCNLM08F09F205L");
			Patient pat7 = insertPatient("MRSRRT05H16F839F", "maria.serra05@gmail.com", "password", "Maria", "Serra", "F", LocalDate.of(2005, 8, 16), "Italian", "Borgo Trento", 12, 37128, "Verona", "3489237647", "Anxiety", "LDGLSN02S18F861T");
			Patient pat8 = insertPatient("RSCFNC06E15F205L", "rosa.scalfini06@gmail.com", "password", "Rosa", "Scalfini", "F", LocalDate.of(2006, 05, 15), "Italian", "Borgo Roma", 54, 37139, "Verona", "3489237648", "Stress", "FRCNLM08F09F205L");
			
			Drug drug1 = insertDrug(0, "Ibuprofen", "Painkiller");
			Drug drug2 = insertDrug(0, "Lorazepam", "Anxiety");
			Drug drug3 = insertDrug(0, "Omeprazole", "Antacid");
			Drug drug4 = insertDrug(0, "Acetaminophen", "Painkiller");
			Drug drug5 = insertDrug(0, "Lisinopril", "Blood Pressure");
			Drug drug6 = insertDrug(0, "Metformin", "Diabetes");
			Drug drug7 = insertDrug(0, "Simvastatin", "Cholesterol");
			Drug drug8 = insertDrug(0, "Prednisone", "Anti-inflammatory");
			Drug drug9 = insertDrug(0, "Amoxicillin", "Antibiotic");
			Drug drug10 = insertDrug(0, "Lansoprazole", "Antacid");


			
			Pathology pathology1 = insertPathology("ALS");
			Pathology pathology2 = insertPathology("Alzheimers");
			Pathology pathology3 = insertPathology("Asthma");
			Pathology pathology4 = insertPathology("Cancer");
			Pathology pathology5 = insertPathology("Diabetes");
			Pathology pathology6 = insertPathology("Epilepsy");
			Pathology pathology7 = insertPathology("Hypertension");
			Pathology pathology8 = insertPathology("Migraine");
			Pathology pathology9 = insertPathology("Parkinsons");
			Pathology pathology10 = insertPathology("Schizophrenia");

					
			
			Symptom symptom1 = insertSymptom("Headache");
			Symptom symptom2 = insertSymptom("Fever");
			Symptom symptom3 = insertSymptom("Cough");
			Symptom symptom4 = insertSymptom("Fatigue");
			Symptom symptom5 = insertSymptom("Nausea");
			Symptom symptom6 = insertSymptom("Vomiting");
			Symptom symptom7 = insertSymptom("Sore throat");
			Symptom symptom8 = insertSymptom("Muscle aches");
			Symptom symptom9 = insertSymptom("Runny or stuffy nose");
			Symptom symptom10 = insertSymptom("Difficulty breathing");
			Symptom symptom11 = insertSymptom("Loss of smell or taste");
			Symptom symptom12 = insertSymptom("Chest pain");
			Symptom symptom13 = insertSymptom("Diarrhea");
			Symptom symptom14 = insertSymptom("Rash");
			Symptom symptom15 = insertSymptom("Dizziness");

			
			
			
        } catch (SQLException e) {
			//e.printStackTrace();
        	System.out.println("Problema nel db");
		} catch (ParseException e) {
			e.printStackTrace();
		} catch (IllegalArgumentException e) {
			System.out.println(e.getMessage());
		}        
        
        
        }
        
        /*System.out.println("Physicians: ");
        ObservableList<Physician> allPhys = getPhysicians();
        for (Physician p: allPhys) {
        	System.out.println(p);
        }
        
        System.out.println("Patients: ");
        ObservableList<Patient> allPat = getPatients();
        for (Patient p: allPat) {
        	System.out.println(p);
        }
        
        System.out.println("Logs: ");
        ObservableList<Log> logs = getLogs();
        for (Log l: logs) {
        	System.out.println(l);
        }
        
        System.out.println("Drugs: ");
        ObservableList<Drug> drugs = getDrugs();
        for (Drug l: drugs) {
        	System.out.println(l);
        }
        
        System.out.println("Therapies: ");
        ObservableList<Therapy> therapies = getTherapies();
        for (Therapy l: therapies) {
        	System.out.println(l);
        }
        
        System.out.println("Drug Intakes: ");
        ObservableList<DrugIntake> drugIntakes = getDrugIntakes();
        for (DrugIntake d: drugIntakes) {
        	System.out.println(d);
        }
        
        System.out.println("Pathologies: ");
        ObservableList<Pathology> pathologies = getPathologies();
        for (Pathology p: pathologies) {
        	System.out.println(p);
        }
        
        System.out.println("Patient_Pathologies: ");
        ObservableList<PatientPathology> patient_pathologies = getPatientPathologies();
        for (PatientPathology p: patient_pathologies) {
        	System.out.println(p);
        }
        
        System.out.println("Measurements: ");
        ObservableList<Measurement> measurements = getMeasurements();
        for (Measurement m: measurements) {
        	System.out.println(m);
        }
        
        System.out.println("Symptoms: ");
        ObservableList<Symptom> symptoms = getSymptoms();
        for (Symptom s: symptoms) {
        	System.out.println(s);
        }
        
        System.out.println("Measurement_Symptoms: ");
        ObservableList<MeasurementSymptom> measurementSymptoms = getMeasurementSymptoms();
        for (MeasurementSymptom m: measurementSymptoms) {
        	System.out.println(m);
        }*/
        
        //conn.close();
        /*loadPeople();
        loadOccupations();*/
    }
    
    /**
	 * Resets and creates the "measurement_therapy" table in the database.
	 *
	 * @throws SQLException if an error occurs while resetting the table
	 */
    public void resetMeasurementTherapiesTable() throws SQLException{
    	String s = "DROP TABLE IF EXISTS measurement_therapy;" +
                "CREATE TABLE measurement_therapy( " +
                "IDmeasurement INTEGER, " +
                "IDtherapy INTEGER, " +
                "FOREIGN KEY(IDmeasurement) REFERENCES measurement(id), " +
                "FOREIGN KEY(IDtherapy) REFERENCES therapy(id), " +
                "PRIMARY KEY(IDmeasurement,IDtherapy) " +
                ");";
        log(s);
        runStatement(s);
    }
    
    /**
	 * Resets and creates the "measurement_pathology" table in the database.
	 *
	 * @throws SQLException if an error occurs while resetting the table
	 */
    public void resetMeasurementPathologiesTable() throws SQLException{
    	String s = "DROP TABLE IF EXISTS measurement_pathology;" +
                "CREATE TABLE measurement_pathology( " +
                "IDmeasurement INTEGER, " +
                "IDpathology INTEGER, " +
                "FOREIGN KEY(IDmeasurement) REFERENCES measurement(id), " +
                "FOREIGN KEY(IDpathology) REFERENCES pathology(id), " +
                "PRIMARY KEY(IDmeasurement,IDpathology) " +
                ");";
        log(s);
        runStatement(s);
    }
    
    /**
	 * Resets and creates the "measurement_symptom" table in the database.
	 *
	 * @throws SQLException if an error occurs while resetting the table
	 */
    public void resetMeasurementSymptomTable() throws SQLException{
    	String s = "DROP TABLE IF EXISTS measurement_symptom;" +
                "CREATE TABLE measurement_symptom( " +
                "IDmeasurement INTEGER, " +
                "IDsymptom INTEGER, " +
                "FOREIGN KEY(IDmeasurement) REFERENCES measurement(id), " +
                "FOREIGN KEY(IDsymptom) REFERENCES symptom(id), " +
                "PRIMARY KEY(IDmeasurement,IDsymptom) " +
                ");";
        log(s);
        runStatement(s);
    }
    
    /**
	 * Resets and creates the "symptom" table in the database.
	 *
	 * @throws SQLException if an error occurs while resetting the table
	 */
    public void resetSymptomTable() throws SQLException{
    	String s = "DROP TABLE IF EXISTS symptom;" +
    			"CREATE TABLE symptom( " +
    		    "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
    		    "description VARCHAR(1024)" +
    		    ");";
        log(s);
        runStatement(s);
    }
    
    /**
	 * Resets and creates the "measurement" table in the database.
	 *
	 * @throws SQLException if an error occurs while resetting the table
	 */
    public void resetMeasurementTable() throws SQLException{
    	String s = "DROP TABLE IF EXISTS measurement;" +
    			"CREATE TABLE measurement( " +
    		    "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
    		    "sbp INTEGER, " +
    		    "dbp INTEGER, " +
    		    "datetime DATETIME, " +
    		    "informations VARCHAR(1024), " +
    		    "CFpatient VARCHAR(16), " +
    		    "FOREIGN KEY(CFpatient) REFERENCES patient(CF)" +
    		    ");";
        log(s);
        runStatement(s);
    }
    
    /**
	 * Resets and creates the "patient_pathology" table in the database.
	 *
	 * @throws SQLException if an error occurs while resetting the table
	 */
    public void resetPatientPathologyTable() throws SQLException{
    	String s = "DROP TABLE IF EXISTS patient_pathology;" +
                "CREATE TABLE patient_pathology( " +
                "CFpatient VARCHAR(16), " +
                "IDpathology INTEGER, " +
                "startDate DATETIME, " +
                "endDate DATETIME, " +
                "FOREIGN KEY(CFpatient) REFERENCES patient(CF), " +
                "FOREIGN KEY(IDpathology) REFERENCES pathology(id), " +
                "PRIMARY KEY(CFpatient,IDpathology) " +
                ");"; 
        log(s);
        runStatement(s);
    }
    
    /**
	 * Resets and creates the "pathology" table in the database.
	 *
	 * @throws SQLException if an error occurs while resetting the table
	 */
    public void resetPathologyTable() throws SQLException{
    	String s = "DROP TABLE IF EXISTS pathology;" +
    			"CREATE TABLE pathology( " +
    		    "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
    		    "description VARCHAR(1024)" +
    		    ");";
        log(s);
        runStatement(s);
    }
    
    /**
	 * Resets and creates the "drugIntakes" table in the database.
	 *
	 * @throws SQLException if an error occurs while resetting the table
	 */
    public void resetDrugIntakesTable() throws SQLException{
        String s = "DROP TABLE IF EXISTS drugIntakes;" +
                "CREATE TABLE drugIntakes( " +
                "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
                "datetime DATETIME, " +
                "quantity INTEGER, "+ 
                "IDtherapy INTEGER, " + 
                "FOREIGN KEY(IDtherapy) REFERENCES therapy(id)" +
                ");";
        log(s);
        runStatement(s);
    }

    /**
	 * Resets and creates the "therapy" table in the database.
	 *
	 * @throws SQLException if an error occurs while resetting the table
	 */
    public void resetTherapyTable() throws SQLException{
        String s = "DROP TABLE IF EXISTS therapy;" +
                "CREATE TABLE therapy( " +
                "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
                "dailydose INTEGER, " +
                "quantity INTEGER, "+ 
                "directions VARCHAR(1024), " + 
                "startDate DATE, " +
                "endDate DATE, " +
                "IDdrug INTEGER, " +
                "CFpatient VARCHAR(16), " +
                "CFphysician VARCHAR(16), " + 
                "FOREIGN KEY(IDdrug) REFERENCES drug(id), " +
                "FOREIGN KEY(CFpatient) REFERENCES patient(CF), " +
                "FOREIGN KEY(CFphysician) REFERENCES physician(CF)" +
                ");";
        log(s);
        runStatement(s);
    }
    
    /**
	 * Resets and creates the "drug" table in the database.
	 *
	 * @throws SQLException if an error occurs while resetting the table
	 */
    public void resetDrugTable() throws SQLException{
        String s = "DROP TABLE IF EXISTS drug;" +
                "CREATE TABLE drug( " +
                "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
                "name VARCHAR(255), " +
                "description VARCHAR(255)" +
                ");";
        log(s);
        runStatement(s);
    }
    
    /**
	 * Resets and creates the "patient" table in the database.
	 *
	 * @throws SQLException if an error occurs while resetting the table
	 */
    public void resetPatientTable() throws SQLException{
        String s = "DROP TABLE IF EXISTS patient;" +
                "CREATE TABLE patient( " +
                "CF VARCHAR(16) PRIMARY KEY, " +
                "email VARCHAR(255), " +
                "password VARCHAR(255), " +
                "name VARCHAR(255), " +
                "surname VARCHAR(255), " +
                "sex VARCHAR(1), " +
                "birthdate DATE, " +
                "nationality VARCHAR(255), " +
                "street VARCHAR(255), " +
                "civicnumber INTEGER, " +
                "cap INTEGER, " +
                "city VARCHAR(255), " +
                "phonenumber VARCHAR(10), " +
                "informations VARCHAR(1024), " +
                "CFphysician VARCHAR(16) NOT NULL, " +
                "FOREIGN KEY (CFphysician) REFERENCES physician(CF) ON UPDATE CASCADE" + 
                ");";
        log(s);
        runStatement(s);
    }

    /**
	 * Resets and creates the "log" table in the database.
	 *
	 * @throws SQLException if an error occurs while resetting the table
	 */
    public void resetLogTable() throws SQLException{
        String s = "DROP TABLE IF EXISTS log;" +
                "CREATE TABLE log( " +
                "CF VARCHAR(16), " +
                "datetime DATETIME, " +
                "informations VARCHAR(255), " +
                "FOREIGN KEY(CF) REFERENCES physician(CF), " +
                "PRIMARY KEY(CF, datetime)" +
                ");";
        log(s);
        runStatement(s);
    }
    
    /**
	 * Resets and creates the "physician" table in the database.
	 *
	 * @throws SQLException if an error occurs while resetting the table
	 */
    public void resetPhysicianTable() throws SQLException{
        String s = "DROP TABLE IF EXISTS physician;" +
                "CREATE TABLE physician( " +
                "CF VARCHAR(16) PRIMARY KEY, " +
                "email VARCHAR(255), " +
                "password VARCHAR(255), " +
                "name VARCHAR(255), " +
                "surname VARCHAR(255), " +
                "sex VARCHAR(1), " +
                "birthdate DATE, " +
                "nationality VARCHAR(255), " +
                "street VARCHAR(255), " +
                "civicnumber INTEGER, " +
                "cap INTEGER, " +
                "city VARCHAR(255), " +
                "phonenumber VARCHAR(10)" +
                ");";
        log(s);
        runStatement(s);
    }
    
    /**
	 * Drops all the tables in the database.
	 *
	 * @throws SQLException if an error occurs while resetting the table
	 */
    public void clearAll() throws SQLException{
        String q = "DROP TABLE measurement_therapy;"+
        		"DROP TABLE measurement_pathology;"+
        		"DROP TABLE measurement_symptom;" +
        		"DROP TABLE symptom;"+
        		"DROP TABLE measurement;"+
        		"DROP TABLE patient_pathology;"+
        		"DROP TABLE pathology;"+
        		"DROP TABLE drugIntakes;"+
        		"DROP TABLE therapy;"+ 
        		"DROP TABLE drug;" +
        		"DROP TABLE patient;" +
        		"DROP TABLE log;" +
        		"DROP TABLE physician;"
        		;
        log(q);
        runStatement(q);
    }
    
    /**
	 * Executes the specified SQL statement and returns the number of rows affected.
	 *
	 * @param s the SQL statement to execute
	 * @return the number of rows affected by executing the statement
	 * @throws SQLException if an error occurs while executing the statement
	 */
    public int runStatementWithOutput(String s) throws SQLException {
        int r;
        Statement stmt  = conn.createStatement();
        r = stmt.executeUpdate(s);
        return r;
    }
    
    /**
	 * Deletes all records from the specified table in the database.
	 *
	 * @param table the name of the table to delete data from
	 * @throws SQLException if an error occurs while deleting data from the table
	 */
    public void deleteDataFromTable(String table) throws SQLException {
    	String q = "DELETE FROM " + table;
    	log(q);
    	runStatement(q);
    }
    
    
    /**
	 * Returns an ObservableList of all {@link MeasurementTherapy} objects in the database.
	 *
	 * @return an ObservableList of all {@link MeasurementTherapy} objects in the database
	 * @throws SQLException if an error occurs while querying the database
	 */
    public ObservableList<MeasurementTherapy> getMeasurementTherapies() throws SQLException{
    	ObservableList<MeasurementTherapy> measurementTherapies = FXCollections.<MeasurementTherapy>observableArrayList(
                measurementTherapy -> new Observable[] {
                        measurementTherapy.IDMeasurementProperty(), 
                        measurementTherapy.IDTherapyProperty()
                        }
        );
    	
    	String q = "SELECT * FROM measurement_therapy";
    	log(q);
    	ResultSet rs = runQuery(q);
    	
    	while(rs.next()) {
    		measurementTherapies.add(new MeasurementTherapy(
    				rs.getInt("IDmeasurement"),
    				rs.getInt("IDtherapy")
    				));
    	}
    	
    	return measurementTherapies;
    }
    
    /**
	 * Tries to insert a new {@link MeasurementTherapy}.
	 *
	 * @param IdMeasurement the measurement id to insert.
	 * @param IdTherapy the therapy id to insert.
	 * @return the {@link MeasurementTherapy} object that was inserted, or null if the insertion failed.
	 * @throws SQLException if there was an error executing the SQL query.
	 * @throws ParseException if there was an error parsing the SQL query.
	 */
	public MeasurementTherapy insertMeasurementTherapy(int IdMeasurement, int IdTherapy) throws SQLException, ParseException {
		log("Add MeasurementTherapy " + IdMeasurement + " " + IdTherapy);
        MeasurementTherapy measurementTherapy = new MeasurementTherapy(IdMeasurement, IdTherapy);
        
        String q = "INSERT INTO measurement_therapy(IDmeasurement, IDtherapy)\n" +
                "VALUES ('"+ measurementTherapy.getIDMeasurement() + "', '"+ measurementTherapy.getIDTherapy() +"')\n" +
                ";";
        int id = runStatementWithOutput(q);
        if (id != 0)return measurementTherapy;
        return null;
	}
    
    
    
    
    
    /**
	 * Returns an ObservableList of all {@link MeasurementPathology} objects in the database.
	 *
	 * @return an ObservableList of all {@link MeasurementPathology} objects in the database
	 * @throws SQLException if an error occurs while querying the database
	 */
    public ObservableList<MeasurementPathology> getMeasurementPathology() throws SQLException{
    	ObservableList<MeasurementPathology> measurementPathologies = FXCollections.<MeasurementPathology>observableArrayList(
                measurementPathology -> new Observable[] {
                        measurementPathology.IDMeasurementProperty(), 
                        measurementPathology.IDPathologyProperty()
                        }
        );
    	
    	String q = "SELECT * FROM measurement_pathology";
    	log(q);
    	ResultSet rs = runQuery(q);
    	
    	while(rs.next()) {
    		measurementPathologies.add(new MeasurementPathology(
    				rs.getInt("IDmeasurement"),
    				rs.getInt("IDpathology")
    				));
    	}
    	
    	return measurementPathologies;
    }
    
    /**
	 * Tries to insert a new {@link MeasurementPathology}.
	 *
	 * @param IdMeasurement the measurement id to insert.
	 * @param IdPathology the pathology id to insert.
	 * @return the {@link MeasurementPathology} object that was inserted, or null if the insertion failed.
	 * @throws SQLException if there was an error executing the SQL query.
	 * @throws ParseException if there was an error parsing the SQL query.
	 */
	public MeasurementPathology insertMeasurementPathology(int IdMeasurement, int IdPathology) throws SQLException, ParseException {
		log("Add MeasurementPathology " + IdMeasurement + " " + IdPathology);
        MeasurementPathology measurementPathology = new MeasurementPathology(IdMeasurement, IdPathology);
        
        String q = "INSERT INTO measurement_pathology(IDmeasurement, IDpathology)\n" +
                "VALUES ('"+ measurementPathology.getIDMeasurement() + "', '"+ measurementPathology.getIDPathology() +"')\n" +
                ";";
        int id = runStatementWithOutput(q);
        if (id != 0)return measurementPathology;
        return null;
	}
    
    
    
    
    
    /**
	 * Returns an ObservableList of all {@link MeasurementSymptom} objects in the database.
	 *
	 * @return an ObservableList of all {@link MeasurementSymptom} objects in the database
	 * @throws SQLException if an error occurs while querying the database
	 */
    public ObservableList<MeasurementSymptom> getMeasurementSymptoms() throws SQLException{
    	ObservableList<MeasurementSymptom> measurementSymptoms = FXCollections.<MeasurementSymptom>observableArrayList(
                measurementSymptom -> new Observable[] {
                        measurementSymptom.IDMeasurementProperty(), 
                        measurementSymptom.IDSymptomProperty()
                        }
        );
    	
    	String q = "SELECT * FROM measurement_symptom";
    	log(q);
    	ResultSet rs = runQuery(q);
    	
    	while(rs.next()) {
    		measurementSymptoms.add(new MeasurementSymptom(
    				rs.getInt("IDmeasurement"),
    				rs.getInt("IDsymptom")
    				));
    	}
    	
    	return measurementSymptoms;
    }
    
    /**
	 * Tries to insert a new {@link MeasurementSymptom}.
	 *
	 * @param IdMeasurement the measurement id to insert.
	 * @param IdSymptom the symptom id to insert.
	 * @return the {@link MeasurementSymptom} object that was inserted, or null if the insertion failed.
	 * @throws SQLException if there was an error executing the SQL query.
	 * @throws ParseException if there was an error parsing the SQL query.
	 */
	public MeasurementSymptom insertMeasurementSymptom(int IdMeasurement, int IdSymptom) throws SQLException, ParseException {
		log("Add MeasurementSymptom " + IdMeasurement + " " + IdSymptom);
        MeasurementSymptom measurementSymptom = new MeasurementSymptom(IdMeasurement, IdSymptom);
        
        String q = "INSERT INTO measurement_symptom(IDmeasurement, IDsymptom)\n" +
                "VALUES ('"+ measurementSymptom.getIDMeasurement() + "', '"+ measurementSymptom.getIDSymptom() +"')\n" +
                ";";
        int id = runStatementWithOutput(q);
        if (id != 0)return measurementSymptom;
        return null;
	}
	
	
	
	
	
	/**
	 * Returns an ObservableList of all {@link Symptom} objects in the database.
	 *
	 * @return an ObservableList of all {@link Symptom} objects in the database
	 * @throws SQLException if an error occurs while querying the database
	 */
    public ObservableList<Symptom> getSymptoms() throws SQLException{
    	ObservableList<Symptom> symptoms = FXCollections.<Symptom>observableArrayList(
                symptom -> new Observable[] {
                        symptom.idProperty(), 
                        symptom.descriptionProperty()
                        }
        );
    	
    	String q = "SELECT * FROM symptom";
    	log(q);
    	ResultSet rs = runQuery(q);
    	
    	while(rs.next()) {
    		symptoms.add(new Symptom(
					rs.getInt("id"),
					rs.getString("description")
					));
    	}
    	
    	return symptoms;
    }
    
	/**
	 * Tries to insert a new {@link Symptom}.
	 *
	 * @param description the symptom.
	 * @return the {@link Symptom} object that was inserted, or null if the insertion failed.
	 * @throws SQLException if there was an error executing the SQL query.
	 * @throws ParseException if there was an error parsing the SQL query.
	 */
	public Symptom insertSymptom(String description) throws SQLException, ParseException {
		log("Add Symptom " + description);
        Symptom symptom = new Symptom(0, description);
        String q = "INSERT INTO symptom(description)\n" +
                "VALUES ('"+ description + "')\n" +
                ";";
        int id = runStatementWithOutput(q);
        if (id != 0)return symptom;
        return null;
	}
    
    
    
    
    
    /**
	 * Returns an ObservableList of all {@link Measurement} objects in the database.
	 *
	 * @return an ObservableList of all {@link Measurement} objects in the database
	 * @throws SQLException if an error occurs while querying the database
	 */
    public ObservableList<Measurement> getMeasurements() throws SQLException{
    	ObservableList<Measurement> measurements = FXCollections.<Measurement>observableArrayList(
                measurement -> new Observable[] {
                        measurement.idProperty(), 
                        measurement.sbpProperty(),
                        measurement.dbpProperty(),                   
                        measurement.dateProperty(),
                        measurement.informationsProperty(),
                        measurement.CFPatientProperty(),
                        }
        );
    	
    	String q = "SELECT * FROM measurement";
    	log(q);
    	ResultSet rs = runQuery(q);
    	
    	while(rs.next()) {
    		measurements.add(new Measurement(
					rs.getInt("id"),
					rs.getInt("sbp"),
					rs.getInt("dbp"),
    				rs.getTimestamp("datetime").toLocalDateTime(),
    				rs.getString("informations"), 
    				rs.getString("CFpatient")
    				));
    	}
    	
    	return measurements;
    }
    
    /**
	 * Tries to insert a new {@link Measurement}.
	 *
	 * @param sbp the sbp pressure.
	 * @param dbp the dp pressure.
	 * @param date the date of the measurement.
	 * @param informations.
	 * @param CFpatient the CF of the patient.
	 * @return the {@link Measurement} object that was inserted, or null if the insertion failed.
	 * @throws SQLException if there was an error executing the SQL query.
	 * @throws ParseException if there was an error parsing the SQL query.
	 */
	public Measurement insertMeasurement(int sbp, int dbp, LocalDateTime date, String informations, String CFpatient) throws SQLException, ParseException {
		log("Add Measurement " + sbp + "  " + dbp);
    	//SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
        //System.out.println(((Date) df.parse(birthdate.toString())).getTime());
        //Long bdate = df.parse(birthdate.toString()).getTime();
        Measurement measurement = new Measurement(0, sbp, dbp, date, informations, CFpatient);
        long timestamp = date.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();

        String q = "INSERT INTO Measurement(sbp, dbp, datetime, informations, CFpatient)\n" +
                "VALUES ('"+ sbp + "', '" + dbp + "', '" + timestamp + "', '" + informations + "', '" + CFpatient + "')\n" +
                "RETURNING id;";
        int id = runStatementWithOutput(q);
        if (id != 0) {
        	return measurement;
        }
        //System.out.println("qui");
        return null;
	}
    
  
  
  
  
    /**
	 * Returns an ObservableList of all {@link PatientPathology} objects in the database.
	 *
	 * @return an ObservableList of all {@link PatientPathology} objects in the database
	 * @throws SQLException if an error occurs while querying the database
	 */
    public ObservableList<PatientPathology> getPatientPathologies() throws SQLException{
    	ObservableList<PatientPathology> patientPathologies = FXCollections.<PatientPathology>observableArrayList(
                patientPathology -> new Observable[] {
                        patientPathology.startDateProperty(), 
                        patientPathology.endDateProperty(),
                        patientPathology.cfPatientProperty(),
                        patientPathology.idPathologyProperty()             
                        }
        );
    	
    	String q = "SELECT * FROM patient_pathology";
    	log(q);
    	ResultSet rs = runQuery(q);
    	
    	while(rs.next()) {
    		patientPathologies.add(new PatientPathology(
					rs.getDate("startDate").toLocalDate(),
    				rs.getDate("endDate") == null ? null : rs.getDate("endDate").toLocalDate(),
    				rs.getString("CFpatient"),
    				rs.getInt("IDpathology")			
    				));
    	}
    	
    	return patientPathologies;
    }
	
	/**
	 * Tries to insert a new {@link PatientPathology}.
	 *
	 * @param CFPatient the cf of the patient.
	 * @param idPathology the pathology id.
	 * @param startDate the starting date of the pathology.
	 * @return the {@link PatientPathology} object that was inserted, or null if the insertion failed.
	 * @throws SQLException if there was an error executing the SQL query.
	 * @throws ParseException if there was an error parsing the SQL query.
	 */
	public PatientPathology insertPatientPathology(String CFPatient, int idPathology, LocalDate startDate) throws SQLException, ParseException {
		log("Add PatientPathology " + CFPatient+ "  " + idPathology + " " + startDate);
        PatientPathology patientPathology = new PatientPathology(startDate, null, CFPatient, idPathology);      
        long timestamp = LocalDateToLong(startDate);
        //long timestamp1;
        String q;
        
        q = "INSERT INTO patient_pathology(CFpatient, IDpathology, startDate)\n" +
                    "VALUES ('" + CFPatient + "', '"+ idPathology + "', '"+ timestamp + "')\n" +
                    ";";
        
        
        int id = runStatementWithOutput(q);
        if (id != 0)return patientPathology;
        return null;
	}
	
	/*Tries to insert a new PatientPathology
	public PatientPathology insertPatientPathology(String CFPatient, int idPathology, LocalDate startDate, LocalDate endDate) throws SQLException, ParseException {
		log("Add PatientPathology " + CFPatient+ "  " + idPathology + " " + startDate + " " + endDate);
        PatientPathology patientPathology = new PatientPathology(startDate, endDate, CFPatient, idPathology);      
        long timestamp = LocalDateToLong(startDate);
        long timestamp1;
        String q;
        if (endDate==null) {
        	q = "INSERT INTO patient_pathology(CFpatient, IDpathology, startDate)\n" +
                    "VALUES ('" + CFPatient + "', '"+ idPathology + "', '"+ timestamp + "')\n" +
                    ";";
        }else {
        	timestamp1 = LocalDateToLong(endDate);
        	q = "INSERT INTO patient_pathology(CFpatient, IDpathology, startDate, endDate)\n" +
                    "VALUES ('" + CFPatient + "', '"+ idPathology + "', '"+ timestamp + "', '" + timestamp1 + "')\n" +
                    ";";
        }
        
        int id = runStatementWithOutput(q);
        if (id != 0)return patientPathology;
        return null;
	}*/
    
    
    
    
    
    /**
	 * Returns an ObservableList of all {@link Pathology} objects in the database.
	 *
	 * @return an ObservableList of all {@link Pathology} objects in the database
	 * @throws SQLException if an error occurs while querying the database
	 */
    public ObservableList<Pathology> getPathologies() throws SQLException{
    	ObservableList<Pathology> pathologies = FXCollections.<Pathology>observableArrayList(
                pathology -> new Observable[] {
                        pathology.idProperty(), 
                        pathology.descriptionProperty()
                        }
        );
    	
    	String q = "SELECT * FROM pathology";
    	log(q);
    	ResultSet rs = runQuery(q);
    	
    	while(rs.next()) {
    		pathologies.add(new Pathology(
    				rs.getInt("id"),
    				rs.getString("description")
    				));
    	}
    	
    	return pathologies;
    }
    
    /**
	 * Tries to insert a new {@link Pathology}.
	 *
	 * @param description the description of the pathology.
	 * @return the {@link Pathology} object that was inserted, or null if the insertion failed.
	 * @throws SQLException if there was an error executing the SQL query.
	 * @throws ParseException if there was an error parsing the SQL query.
	 */
	public Pathology insertPathology(String description) throws SQLException, ParseException {
		log("Add Pathology " + description);
        Pathology pathology = new Pathology(0, description);
        

        String q = "INSERT INTO Pathology(description)\n" +
                "VALUES ('"+ pathology.getDescription() + "')\n" +
                ";";
        int id = runStatementWithOutput(q);
        if (id != 0)return pathology;
        //System.out.println("qui");
        return null;
	}
    
    
    
    
    
    /**
	 * Returns an ObservableList of all {@link DrugIntake} objects in the database.
	 *
	 * @return an ObservableList of all {@link DrugIntake} objects in the database
	 * @throws SQLException if an error occurs while querying the database
	 */
    public ObservableList<DrugIntake> getDrugIntakes() throws SQLException{
    	ObservableList<DrugIntake> drugIntakes = FXCollections.<DrugIntake>observableArrayList(
                drugIntake -> new Observable[] {
                        drugIntake.idProperty(), 
                        drugIntake.datetimeProperty(),
                        drugIntake.quantityProperty(),
                        drugIntake.IDTherapyProperty()
                        }
        );
    	
    	String q = "SELECT * FROM drugIntakes";
    	log(q);
    	ResultSet rs = runQuery(q);
    	
    	while(rs.next()) {
    		drugIntakes.add(new DrugIntake(
					rs.getInt("id"),
    				rs.getTimestamp("datetime").toLocalDateTime(),
    				rs.getInt("quantity"), 
    				rs.getInt("IDtherapy")
    				));
    	}
    	
    	return drugIntakes;
    }
    
    /**
	 * Tries to insert a new {@link DrugIntake}.
	 *
	 * @param idDrugIntake the id of the drug intake.
	 * @param datetime the time of the intake.
	 * @param quantity the quantity taken.
	 * @param idTherapy the id of the therapy.
	 * @return the {@link DrugIntake} object that was inserted, or null if the insertion failed.
	 * @throws SQLException if there was an error executing the SQL query.
	 * @throws ParseException if there was an error parsing the SQL query.
	 */
	public DrugIntake insertDrugIntake(int idDrugIntake, LocalDateTime datetime, int quantity, int idTherapy) throws SQLException, ParseException {
		log("Add DrugIntake " + idDrugIntake + "  " + datetime + " " + quantity + " " + idTherapy);
        DrugIntake drugIntake = new DrugIntake(0, datetime, quantity, idTherapy);      
        long timestamp = datetime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
        String q = "INSERT INTO drugIntakes(datetime, quantity, IDtherapy)\n" +
                "VALUES ('"+ timestamp + "', '"+ drugIntake.getQuantity() + "', '" + drugIntake.getIDTherapy() + "')\n" +
                ";";
        int id = runStatementWithOutput(q);
        if (id != 0)return drugIntake;
        return null;
	}
    
    
    
    
    
    /**
	 * Returns an ObservableList of all {@link Therapy} objects in the database.
	 *
	 * @return an ObservableList of all {@link Therapy} objects in the database
	 * @throws SQLException if an error occurs while querying the database
	 */
    public ObservableList<Therapy> getTherapies() throws SQLException{
    	ObservableList<Therapy> therapies = FXCollections.<Therapy>observableArrayList(
                therapy -> new Observable[] {
                        therapy.idProperty(), 
                        therapy.dailydoseProperty(),
                        therapy.quantityProperty(),
                        therapy.directionsProperty(),
                        therapy.startDateProperty(),
                        therapy.endDateProperty(),
                        therapy.IDDrugProperty(),
                        therapy.CFPatientProperty(),
                        therapy.CFPhysicianProperty()
                        }
        );
    	
    	String q = "SELECT * FROM therapy";
    	log(q);
    	ResultSet rs = runQuery(q);
    	
    	while(rs.next()) {
    		therapies.add(new Therapy(
    				rs.getInt("id"),
    				rs.getInt("dailydose"),
    				rs.getInt("quantity"),
    				rs.getString("directions"),
    				rs.getDate("startDate").toLocalDate(),
    				(rs.getDate("endDate") == null ? null : rs.getDate("endDate").toLocalDate()),
    				rs.getInt("IDdrug"),
    				rs.getString("CFpatient"),
    				rs.getString("CFphysician")
    				));
    	}
    	
    	return therapies;
    }
    
    /**
	 * Tries to insert a new {@link Therapy}.
	 *
	 * @param dailydose how many times per day.
	 * @param quantity how much per dose.
	 * @param directions instructions for taking the drug.
	 * @param startDate the starting date of the therapy.
	 * @param endDate the ending date of the therapy.
	 * @param IDdrug the drug id.
	 * @param CFPatient the cf of the patient who will follow the therapy.
	 * @param CFPhysician the cf of the physician which prescribes the therapy.
	 * @return the {@link Therapy} object that was inserted, or null if the insertion failed.
	 * @throws SQLException if there was an error executing the SQL query.
	 * @throws ParseException if there was an error parsing the SQL query.
	 */
	public Therapy insertTherapy(int dailydose, int quantity, String directions, LocalDate startDate, LocalDate endDate, int IDdrug, String CFPatient, String CFPhysician) throws SQLException, ParseException {
		log("Add Therapy " + IDdrug + "  " + CFPatient + "  " + CFPhysician);
    	//SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
        //System.out.println(((Date) df.parse(birthdate.toString())).getTime());
        //Long bdate = df.parse(birthdate.toString()).getTime();
		Therapy therapy = new Therapy(0, dailydose, quantity, directions, startDate, endDate, IDdrug, CFPatient, CFPhysician);
	        
		Long startDateLong =  LocalDateToLong(startDate);
		String q;
		if (endDate == null) {
			q = "INSERT INTO Therapy(dailydose, quantity, directions, startDate, IDdrug, CFpatient, CFphysician)\n" +
	                "VALUES ('"+ therapy.getDailydose() + "', '"+ therapy.getQuantity() + "', '" + therapy.getDirections() + "', '" + startDateLong + "', '" + therapy.getIDDrug() + "', '" + therapy.getCFPatient() + "', '" + therapy.getCFPhysician() + "')\n" +
	                ";";
			
		}else {
			Long endDateLong =  LocalDateToLong(endDate);
			q = "INSERT INTO Therapy(dailydose, quantity, directions, startDate, endDate, IDdrug, CFpatient, CFphysician)\n" +
	                "VALUES ('"+ therapy.getDailydose() + "', '"+ therapy.getQuantity() + "', '" + therapy.getDirections() + "', '" + startDateLong + "', '" + endDateLong + "', '" + therapy.getIDDrug() + "', '" + therapy.getCFPatient() + "', '" + therapy.getCFPhysician() + "')\n" +
	                ";";
		}    
        
        int id = runStatementWithOutput(q);
        if (id != 0)return therapy;
        //System.out.println("qui");
        return null;
	}
	
	
	
	
	
	/**
	 * Returns an ObservableList of all {@link Drug} objects in the database.
	 *
	 * @return an ObservableList of all {@link Drug} objects in the database
	 * @throws SQLException if an error occurs while querying the database
	 */
    public ObservableList<Drug> getDrugs() throws SQLException{
    	ObservableList<Drug> drugs = FXCollections.<Drug>observableArrayList(
                drug -> new Observable[] {
                        drug.idProperty(), 
                        drug.nameProperty(),
                        drug.descriptionProperty()
                        }
        );
    	
    	String q = "SELECT * FROM drug";
    	log(q);
    	ResultSet rs = runQuery(q);
    	
    	while(rs.next()) {
    		drugs.add(new Drug(
    				rs.getInt("id"),
    				rs.getString("name"), 
    				rs.getString("description")
    				));
    	}
    	
    	return drugs;
    }
	
	/**
	 * Tries to insert a new {@link Drug}.
	 *
	 * @param idDrug the id of the drug.
	 * @param name the name of the drug.
	 * @param description the description of the drug.
	 * @return the {@link Drug} object that was inserted, or null if the insertion failed.
	 * @throws SQLException if there was an error executing the SQL query.
	 * @throws ParseException if there was an error parsing the SQL query.
	 */
	public Drug insertDrug(int idDrug, String name, String description) throws SQLException, ParseException {
		log("Add Drug " + idDrug + "  " + name + " " + description);
        Drug drug = new Drug(0, name, description);
        String q = "INSERT INTO drug(name, description)\n" +
                "VALUES ('"+ drug.getName() + "', '" + drug.getDescription() + "')\n" +
                ";";
        int id = runStatementWithOutput(q);
        if (id != 0)return drug;
        return null;
	}
    
    
    
    
        
    /**
	 * Returns an ObservableList of all Log objects in the database.
	 *
	 * @return an ObservableList of all Log objects in the database
	 * @throws SQLException if an error occurs while querying the database
	 */
    public ObservableList<Log> getLogs() throws SQLException{
    	ObservableList<Log> logs = FXCollections.<Log>observableArrayList(
                log -> new Observable[] {
                        log.cfPhysicianProperty(), 
                        log.dateTimeProperty(),
                        log.informationsProperty()
                        }
        );
    	
    	String q = "SELECT * FROM log";
    	log(q);
    	ResultSet rs = runQuery(q);
    	
    	while(rs.next()) {
    		logs.add(new Log(
    				rs.getTimestamp("datetime").toLocalDateTime(),
    				rs.getString("informations"), 
    				rs.getString("CF")
    				));
    	}
    	
    	return logs;
    }
    
    /*Tries to insert a new Log*/
	public Log insertLog(String CF, LocalDateTime datetime, String informations) throws SQLException, ParseException {
		log("Add Log " + CF + "  " + datetime);
    	//SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
        //System.out.println(((Date) df.parse(birthdate.toString())).getTime());
        //Long bdate = df.parse(birthdate.toString()).getTime();
        Log log = new Log(datetime, informations, CF);
        
        long timestamp = datetime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();

        System.out.println(log.getCFPhysician());
        String q = "INSERT INTO Log(CF, datetime, informations)\n" +
                "VALUES ('"+ log.getCFPhysician() + "', '"+ timestamp + "', '" + log.getInformations() + "')\n" +
                ";";
        int id = runStatementWithOutput(q);
        if (id != 0)return log;
        //System.out.println("qui");
        return null;
	}
    
    
    
    
  
    /**
	 * Returns an ObservableList of all {@link Physician} objects in the database.
	 *
	 * @return an ObservableList of all {@link Physician} objects in the database
	 * @throws SQLException if an error occurs while querying the database
	 */
    public ObservableList<Physician> getPhysicians() throws SQLException{
    	ObservableList<Physician> physicians = FXCollections.<Physician>observableArrayList(
                physician -> new Observable[] {
                        physician.CFProperty(), 
                        physician.emailProperty(),
                        physician.passwordProperty(), 
                        physician.nameProperty(), 
                        physician.surnameProperty(), 
                        physician.sexProperty(), 
                        physician.birthdateProperty(), 
                        physician.nationalityProperty(), 
                        physician.streetProperty(), 
                        physician.civicNumberProperty(),
                        physician.capProperty(), 
                        physician.cityProperty(), 
                        physician.phoneNumberProperty()}
        );
    	
    	String q = "SELECT * FROM physician";
    	log(q);
    	ResultSet rs = runQuery(q);
    	
    	while(rs.next()) {
    		physicians.add(new Physician(
    				rs.getString("CF"), 
    				rs.getString("email"), 
    				rs.getString("password"), 
    				rs.getString("name"), 
    				rs.getString("surname"), 
    				rs.getString("sex"), 
    				rs.getDate("birthdate").toLocalDate(), 
    				rs.getString("nationality"), 
    				rs.getString("street"), 
    				rs.getInt("civicnumber"), 
    				rs.getInt("cap"), 
    				rs.getString("city"), 
    				rs.getString("phonenumber")
    				));
    	}
    	
    	return physicians;
    }
    
    /**
	 * Tries to insert a new {@link Physician}.
	 *
	 * @param CF the cf of the physician.
	 * @param email the email of the physician.
	 * @param password the password of the physician.
	 * @param name the name of the physician.
	 * @param surname the surname of the physician.
	 * @param sex the sex of the physician.
	 * @param birthdate the birthdate of the physician.
	 * @param nationality the nationality of the physician.
	 * @param street the street of the physician.
	 * @param civic_number the civic_number of the physician.
	 * @param cap the cap of the physician.
	 * @param city the city of the physician.
	 * @param phone_number the phone_number of the physician.
	 * @return the {@link Physician} object that was inserted, or null if the insertion failed.
	 * @throws SQLException if there was an error executing the SQL query.
	 * @throws ParseException if there was an error parsing the SQL query.
	 */
    public Physician insertPhysician(String CF, String email, String password, String name, String surname, String sex, LocalDate birthdate, String nationality, String street, int civic_number, int cap, String city, String phone_number) throws SQLException, ParseException {
    	log("Add Physician " + CF);
    	//SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
        //System.out.println(((Date) df.parse(birthdate.toString())).getTime());
        //Long bdate = df.parse(birthdate.toString()).getTime();
        Long bdate = LocalDateToLong(birthdate);
        password = hashPassword(password);
        Physician physician = new Physician(CF, email, password, name, surname, sex, birthdate, nationality, street, civic_number, cap, city, phone_number);
        
        String q = "INSERT INTO Physician(CF, email, password, name, surname, sex, birthdate, nationality, street, civicnumber, cap, city, phonenumber)\n" +
                "VALUES ('"+ physician.getCF() + "', '"+ physician.getEmail() + "', '" + physician.getPassword() + "', '"+ physician.getName() +"', '"+ physician.getSurname() + "', '"+ physician.getSex() +"', '" + bdate + "', '"+ physician.getNationality() + "', '"+ physician.getStreet() + "', '"+ physician.getCivicNumber() + "', '"+ physician.getCAP() + "', '"+ physician.getCity() + "', '"+ physician.getPhoneNumber() +"')\n" +
                ";";
        int id = runStatementWithOutput(q);
        if (id != 0)return physician;
        return null;
    }  
    
    
    
    
    
    /**
	 * Returns an ObservableList of all {@link Patient} objects in the database.
	 *
	 * @return an ObservableList of all {@link Patient} objects in the database
	 * @throws SQLException if an error occurs while querying the database
	 */
    public ObservableList<Patient> getPatients() throws SQLException{
    	ObservableList<Patient> patients = FXCollections.<Patient>observableArrayList(
                patient -> new Observable[] {
                        patient.CFProperty(), 
                        patient.emailProperty(), 
                        patient.passwordProperty(), 
                        patient.nameProperty(), 
                        patient.surnameProperty(), 
                        patient.sexProperty(), 
                        patient.birthdateProperty(), 
                        patient.nationalityProperty(), 
                        patient.streetProperty(), 
                        patient.civicNumberProperty(), 
                        patient.capProperty(), 
                        patient.cityProperty(), 
                        patient.phoneNumberProperty(), 
                        patient.informationsProperty(), 
                        patient.CFPhysicianProperty()}
        );
    	
    	String q = "SELECT * FROM patient";
    	log(q);
    	ResultSet rs = runQuery(q);
    	
    	while(rs.next()) {
    		patients.add(new Patient(
    				rs.getString("CF"), 
    				rs.getString("email"), 
    				rs.getString("password"), 
    				rs.getString("name"), 
    				rs.getString("surname"), 
    				rs.getString("sex"), 
    				rs.getDate("birthdate").toLocalDate(), 
    				rs.getString("nationality"), 
    				rs.getString("street"), 
    				rs.getInt("civicnumber"), 
    				rs.getInt("cap"), 
    				rs.getString("city"), 
    				rs.getString("phonenumber"),
    				rs.getString("informations"),
    				rs.getString("CFphysician")
    				));
    	}
    	
    	return patients;
    }
    
    /**
	 * Tries to insert a new {@link Patient}.
	 *
	 * @param CF the cf of the patient.
	 * @param email the email of the patient.
	 * @param password the password of the patient.
	 * @param name the name of the patient.
	 * @param surname the surname of the patient.
	 * @param sex the sex of the patient.
	 * @param birthdate the birthdate of the patient.
	 * @param nationality the nationality of the patient.
	 * @param street the street of the patient.
	 * @param civic_number the civic_number of the patient.
	 * @param cap the cap of the patient.
	 * @param city the city of the patient.
	 * @param phone_number the phone_number of the patient.
	 * @param informations the informations of the patient.
	 * @param CFPhysician the CFPhysician of the physician of the patient.
	 * @return the {@link Patient} object that was inserted, or null if the insertion failed.
	 * @throws SQLException if there was an error executing the SQL query.
	 * @throws ParseException if there was an error parsing the SQL query.
	 */
	public Patient insertPatient(String CF, String email, String password, String name, String surname, String sex, LocalDate birthdate, String nationality, String street, int civic_number, int cap, String city, String phone_number,String informations, String CFPhysician) throws SQLException, ParseException {
		log("Add Patient " + CF);
    	//SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
        //System.out.println(((Date) df.parse(birthdate.toString())).getTime());
        //Long bdate = df.parse(birthdate.toString()).getTime();
        
		Long bdate = LocalDateToLong(birthdate);
		password = hashPassword(password);
        Patient patient = new Patient(CF, email, password, name, surname, sex, birthdate, nationality, street, civic_number, cap, city, phone_number, informations, CFPhysician);
        
        String q = "INSERT INTO Patient(CF, email, password, name, surname, sex, birthdate, nationality, street, civicnumber, cap, city, phonenumber, informations, CFphysician)\n" +
                "VALUES ('"+ patient.getCF() + "', '"+ patient.getEmail() + "', '" + patient.getPassword() + "', '"+ patient.getName() +"', '"+ patient.getSurname() + "', '"+ patient.getSex() +"', '" + bdate + "', '"+ patient.getNationality() + "', '"+ patient.getStreet() + "', '"+ patient.getCivicNumber() + "', '"+ patient.getCAP() + "', '"+ patient.getCity() + "', '"+ patient.getPhoneNumber() +"', '"+ patient.getInformations() +"', '"+ patient.getCFPhysician() +"')\n" +
                ";";
        int id = runStatementWithOutput(q);
        if (id != 0)return patient;
        //System.out.println("qui");
        return null;
	}





    /**
	 * Returns an ObservableList of all Patient of a specified Physician.
	 *
	 * @return an ObservableList of all Patient of a specified Physician
	 * @throws SQLException if an error occurs while querying the database
	 */
    public ObservableList<Patient> getPatientsPhysician(String CFPhysician) throws SQLException{
    	ObservableList<Patient> patients = FXCollections.<Patient>observableArrayList(
                patient -> new Observable[] {
                        patient.CFProperty(), 
                        patient.emailProperty(), 
                        patient.passwordProperty(), 
                        patient.nameProperty(), 
                        patient.surnameProperty(), 
                        patient.sexProperty(), 
                        patient.birthdateProperty(), 
                        patient.nationalityProperty(), 
                        patient.streetProperty(), 
                        patient.civicNumberProperty(), 
                        patient.capProperty(), 
                        patient.cityProperty(), 
                        patient.phoneNumberProperty(), 
                        patient.informationsProperty(), 
                        patient.CFPhysicianProperty()}
        );
    	
    	String q = "SELECT * FROM patient WHERE CFPhysician='" + CFPhysician + "';";
    	log(q);
    	ResultSet rs = runQuery(q);
    	
    	while(rs.next()) {
    		patients.add(new Patient(
    				rs.getString("CF"), 
    				rs.getString("email"), 
    				rs.getString("password"), 
    				rs.getString("name"), 
    				rs.getString("surname"), 
    				rs.getString("sex"), 
    				rs.getDate("birthdate").toLocalDate(), 
    				rs.getString("nationality"), 
    				rs.getString("street"), 
    				rs.getInt("civicnumber"), 
    				rs.getInt("cap"), 
    				rs.getString("city"), 
    				rs.getString("phonenumber"),
    				rs.getString("informations"),
    				rs.getString("CFphysician")
    				));
    	}
    	
    	return patients;
    }





    /**
     * Returns a ObservableList of all {@link Patient} of a specified Physician that contains the String 'like'.
     *
	 * @param CFPhysician the Fiscal Code of the Physician who has the Patients to search
     * @param like the String to search in the Patients' data
     * @return the ObservableList of {@link Patient} that match the search criteria
     * @throws SQLException if there is an error executing the SQL query
	 */
    public ObservableList<Patient> getSearchedPatients(String CFPhysician, String like) throws SQLException{
    	ObservableList<Patient> patients = FXCollections.<Patient>observableArrayList(
                patient -> new Observable[] {
                        patient.CFProperty(), 
                        patient.emailProperty(), 
                        patient.passwordProperty(), 
                        patient.nameProperty(), 
                        patient.surnameProperty(), 
                        patient.sexProperty(), 
                        patient.birthdateProperty(), 
                        patient.nationalityProperty(), 
                        patient.streetProperty(), 
                        patient.civicNumberProperty(), 
                        patient.capProperty(), 
                        patient.cityProperty(), 
                        patient.phoneNumberProperty(), 
                        patient.informationsProperty(), 
                        patient.CFPhysicianProperty()}
        );
    	
    	String q = "SELECT * FROM patient WHERE CFPhysician='" + CFPhysician + "' AND CF LIKE '" + like + "';";
    	log(q);
    	ResultSet rs = runQuery(q);
    	
    	while(rs.next()) {
    		patients.add(new Patient(
    				rs.getString("CF"), 
    				rs.getString("email"), 
    				rs.getString("password"), 
    				rs.getString("name"), 
    				rs.getString("surname"), 
    				rs.getString("sex"), 
    				rs.getDate("birthdate").toLocalDate(), 
    				rs.getString("nationality"), 
    				rs.getString("street"), 
    				rs.getInt("civicnumber"), 
    				rs.getInt("cap"), 
    				rs.getString("city"), 
    				rs.getString("phonenumber"),
    				rs.getString("informations"),
    				rs.getString("CFphysician")
    				));
    	}
    	
    	return patients;
    }




    
	/**
	 * Tries to update an existent {@link Patient} in the database with the given informations.
	 *
	 * @param CF The unique fiscal code of the patient.
	 * @param informations The new informations to be updated for the patient.
	 * @throws SQLException if an error occurs while accessing the database.
	 */
    public void updatePatient(String CF,String informations) throws SQLException {
    	log("Update Patient " + CF);
        
        String q = "UPDATE patient SET informations = '" + informations + "' WHERE CF = '" + CF +"';";

        runStatementWithOutput(q);
        
    }




	
	/**
	 * This method takes in a password as a String and returns its SHA-256 hash as a String.
	 *
	 * @param password the password to be hashed.
	 * @return the hashed password as a String.
	 */
	public String hashPassword(String password) {
		try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] hash = md.digest(password.getBytes(StandardCharsets.UTF_8));
            StringBuilder sb = new StringBuilder();
            for (byte b : hash) {
                sb.append(String.format("%02x", b));
            }
            return sb.toString();
        } catch (NoSuchAlgorithmException ex) {
            throw new RuntimeException(ex);
        }
		
	}




	/**
	 * Converts a LocalDate object to a Long value.
	 *
	 * @param birthdate The LocalDate object to be converted.
	 * @return The Long value.
	 * @throws ParseException If there is an error parsing the birthdate string.
	 */
	public Long LocalDateToLong(LocalDate birthdate) throws ParseException {
		SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
        System.out.println(((Date) df.parse(birthdate.toString())).getTime());
        Long bdate = df.parse(birthdate.toString()).getTime();
        return bdate;
	}




	    
    /**
     * Initializes the database instance or returns the one already initialized.
     *
     * @return the initialized instance of the database model
     * @throws SQLException if there is an error connecting to the database
     */
    public static synchronized DB_Model getInstance() throws SQLException{
        if (single_instance == null)
            single_instance = new DB_Model();

        return single_instance;
    }
    
    
    
    
    
    /**
     * Closes the connection to the db.
     *
     * @throws SQLException if there is an error closing the connection.
     */
    public void closeConnection() throws SQLException {
    	conn.close();
    }
}
